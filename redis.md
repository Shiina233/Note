### 持久化

redis采用内存存储数据，因此断电后内存中的所有数据就会被丢失，所以需要一种机制来保存内存中的数据，使其==断电后不会消失==，从而使其持久化。即数据能够长久保存下来。持久化有以下两种方式：快照和只追加文件(AOF)

#### 快照

- 通过创建快照来存储当前内存里面的数据在某个时间点上的副本，也就是将当前内存里的数据写入到磁盘上
- 问题，数据太多的时候创建快照会比较费时间。可以通过脚本在半夜创建快照

#### AOF

- 可追加文件，即将执行的写命令写到AOF文件的末尾，以此来记录发生的变化。在断电后，就可以通过重新执行AOF文件的命令来恢复数据，同步频率建议设置为每秒同步一次，即每秒将缓冲里的命令写入到磁盘。不建议每个命令都写入磁盘，这会导致redis性能受到磁盘限制。
- 问题，随着redis的运行，AOF文件会越变越大，重启后恢复所需的时间也越来越长。体积问题可以通过bgrewriteaof命令来移除冗余命令来重写AOF文件

### 复制

- 复制即让其他服务器拥有一个不断更新的副本，也就是从服务器。复制可以用来做读分离，分担主服务器的读负担
- 主服务器可以设置从服务器，通过在从服务器上的slaveof host port命令
- 当复制启动时，即从服务器连接主服务器时
- 从服务器也可以拥有自己的从服务器，即形成主从链，也可以组成树状结构来分担主服务器的复制工作
- 不可以互为主服务器，即不支持主主复制，这样只会占据大量资源

#### 主服务器

- 执行BGSAVE创建一个快照，并记录之后的所有写命令
- 发送快照文件，并继续记录写命令
- 快照发送完毕后，开始发送缓冲区记录的写命令
- 发送完后，没执行一个写命令，向从服务器发送该命令

#### 从服务器

- 向主服务器发送sync命令
- 根据配置文件决定是否接受客户端的命令
- 丢弃旧数据，载入发送来的快照文件
- 快照载入完成后，接受客户端命令
- 接受主服务器发送来的存储在缓冲区的写命令

#### 文件损坏

- 在服务器故障后，快照文件和AOF文件可能会损坏，对于AOF文件损坏了可以通过redis-check-aof命令加上--fix参数来删除不完整的命令即以后的命令
- 快照文件损坏后无解，只能事前将重要的文件备份

### 事务

- redis的事务并不同于关系型数据库，redis的事务并不能回滚，redis事务是redis只能执行一个事务，当一个事务执行完成后，才会去执行另外的事务
- pipline，流水线，通常客户端发送命令给redis是一个一个发送，而用了流水线就会一次性将多个命令发送给redis，即一次性发送多个命令，然后等待所有回复出现，它可以减少网络通信次数
- 事务缺点，因为是所有命令一次提交，在提交前不会执行任何命令，也就不会返回任何值，这就造成了不能根据返回值来判断是否执行其他命令这种情况

### 过期时间

- 可以对key设置过期时间，使其到期后自动删除。但这个方法具有一定的局限性，即只能对key设置过期时间，不能对key里面的值设置
- 过期时间主要有两种，生存时间和过期时间，生存时间即多久后删除，过期时间就是在什么时候删除

### 删除策略

- 一个键到过期时间后就成为了过期的键，此时就需要删除，但是每个键一过期就去删除开销太大，一般会有三种淘汰策略
- 第一种是定时删除，到时间点了就删除全部过期的键
- 第二种是懒惰删除，过期的键暂时不被删除，当被查询时才会被删除
- 第三种是定期删除，每隔一段时间才去删除过期的键，而且删除的频率和时长是受到限制的，过期的键比较多时可能只会删除部分键
- redis采用的是懒惰删除和定期删除，即每隔一段时间删除一定的过期键，并且查询的键过期时会删除它
- redis中的定期删除有点不同，redis会把所有设置了过期时间的key建立一个字典，然后会定期扫描这个字典来删除过期的key。redis并不会一次性删除全部过期的key，而是从字典中选取一些key来删除过期的key，当过期的key超过一定的比例，就会再选取一些key来进行删除，直到低于这个比例，默认是每隔100ms扫描一次，每次选取20个key，当其中的过期键占25%以上时，就会再次选20个key，重复进行

### 内存淘汰策略

- 以上的删除策略会导致一些问题，也就是可能有一些过期的key会被漏掉，内存中积累大量key可能会导致内存耗尽
- 当内存接近耗尽或者接近设定的最大内存值时，就会走内存淘汰策略
- 内存淘汰策略主要有以下几种
- allkeys-random：从所有的key中随机选取key删除

